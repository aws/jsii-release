#!/bin/bash
set -eu

###
#
# Pushes a directory of golang modules to a GitHub repository.
#
# Usage: ./jsii-release-golang [DIR]
#
# DIR is a directory where the golang modules are located (default is `dist/go`). Modules can be located either in subdirectories, (e.g 'dist/go/my-module/go.mod')
#     or in the root (e.g 'dist/go/go.mod').
#
# If you specify the `VERSION` env variable, all modules will recieve that version, otherwise a `version` file is expected to exist in each module directory.
# Repository tags will be in the following format:
#
#  - For a module located at the root: `v${module_version}` (e.g `v1.20.1`)
#  - For modules located inside subdirectories: `<subdir-name>/v${module_version}` (e.g `my-module/v3.3.1`)
#
# GITHUB_TOKEN       (required): Authentication token that allows to push and tag the repository.
# VERSION            (optional): Global repository version.
# GITHUB_REPO        (optional): GitHub repository to push to. Default is derived from the module name.
# GIT_BRANCH         (optional): Branch to push to. Defaults to 'main'.
# GIT_USER_NAME      (optional): Username to perform the commit with. Defaults to the global git user.name config. Fails it it doesn't exist.
# GIT_USER_EMAIL     (optional): Email to perform the commit with. Defaults to the global git user.email config. Fails it it doesn't exist.
# GIT_COMMIT_MESSAGE (optional): The commit message. Defaults to 'chore(release): $VERSION'.
# DRYRUN             (optional): Set to "true" for a dry run
###

dir=${1:-dist/go}
GIT_BRANCH=${GIT_BRANCH:-main}

# these shenanigens allow functions invoked with command substitutions (i.e $())
# to call "error" and abort the entire execution. basically behaves like throwing an exception.
# otherwise it just exists the subshell, and the main script continues with the error as the output value.
# if anyone has a better way...please offer it, decided to cap it at an hour of trial and error :)
error_file=$(mktemp -d)/jsii-release.error
touch ${error_file}
trap "cat ${error_file} && exit 1" TERM
export OUR_PID=$$
error() { echo "‚ùå $@" >> ${error_file}; kill -s TERM ${OUR_PID}; }

if [[ "$dir" != /* ]]; then
  # if given a relative path, remember the full path since we might be changing dirs later on
  dir="$(pwd)/${dir}"
fi

if ! command -v git &> /dev/null; then
  error "git must be available to run this script"
fi

if [ -z "${GIT_USER_NAME:-}" ]; then
  GIT_USER_NAME=$(git config user.name) || error "Unable to detect username. either configure a global git user.name or pass GIT_USER_NAME env variable"
fi

if [ -z "${GIT_USER_EMAIL:-}" ]; then
  GIT_USER_EMAIL=$(git config user.email) || error "Unable to detect user email. either configure a global git user.email or pass GIT_USER_EMAIL env variable"
fi

dry_run=false
if [[ ${DRYRUN:-"false"} = "true" ]]; then
  echo "==========================================="
  echo "            üèúÔ∏è DRY-RUN MODE üèúÔ∏è"
  echo "==========================================="
  dry_run=true
fi

if [ ! -d ${dir} ]; then
  error "${dir} either doesnt exist or is not a directory"
fi

if [ -z "${GITHUB_TOKEN:-}" ]; then
  error "GITHUB_TOKEN env variable is required"
fi

# Creates the default commit message. if the repository uses a single version
# the message will be 'chore(release): ${VERSION}'. Otherwise, this will concatenate
# modules with their correponding version. For example: `chore(release): module1@1.20.1 module2@1.21.1`
function create_release_message {
  modules=$1

  message="chore(release):"

  if [ ! -z ${VERSION} ]; then
    message="${message} ${VERSION}"
  else
    for module in "${modules[@]}"; do
      module_name=$(basename ${module})
      module_version=$(extract_version ${module})
      message="${message} ${module_name}@${module_version}"
    done
  fi

  echo ${message}
}

# Extrats the version of a specific module. If `VERSION` is set, just returns that.
# Otherwise, reads the `version` file in the module directory.
# Fails if none exist.
function extract_version {
  module=$1
  if [ ! -z "${VERSION:-}" ]; then
    module_version=${VERSION}
  elif [ -f ${module}/version ]; then
    module_version=$(cat ${module}/version)
  else
    error "Unable to determine version of module ${module}. Either include a 'version' file, or specify a global version using the VERSION environment variable."
  fi

  echo ${module_version}
}

# Extracts the repository name from the collection of modules
# by parsing the go.mod file of one of the modules, assuming all modules are pushed
# to the same repository.
function extract_repo {
  modules=$1
  go_mod=${modules[0]}/go.mod
  full_module_name=$(grep module ${go_mod} | cut -d ' ' -f 2)
  owner=$(echo ${full_module_name} | cut -d '/' -f 2)
  repo=$(echo ${full_module_name} | cut -d '/' -f 3)
  echo ${owner}/${repo}
}

# Creates the necessary tag for a given module.
# If the module is located at the root directory, the tag will in the form of `v${module_version}`.
# Otherwise, the module name is prefixed to it, e.g `my-module/v${module_version}`.
function create_tag {
  module=$1
  repo_name=$2

  module_name=$(basename ${module})
  module_version=$(extract_version ${module})

  if [ ${module} = ${dir} ]; then
    # root module
    tag_name=v${module_version}
  else
    # submodule
    tag_name=${module_name}/v${module_version}
  fi

  git tag -a ${tag_name} -m ${tag_name}
  if $dry_run; then
    echo "Will push tag: ${tag_name}"
  else
    git push origin ${tag_name}
  fi
}

# Delete all modules in the target repository in preparation of
# syncing it with the source code located in `DIR`.
function purge_modules {
  repo_dir=$1

  # first remove all submodules
  for subdir in $(find ${repo_dir} -mindepth 1 -maxdepth 1 -type d); do
    if [ -f ${subdir}/go.mod ]; then
      rm -r ${subdir}
    fi
  done

  # if the root is a module too, remove the entire repo.
  if [ -f ${dir}/go.mod ]; then
    rm -r ${repo_dir}/*
  fi

}

modules=()

# collect mod files from root and subdirectories
for go_mod in $(find ${dir} -name go.mod -mindepth 1 -maxdepth 2); do
  modules+=($(dirname ${go_mod}))
done

# at least one go module must exist
if [ ${#modules[@]} -eq 0 ]; then
  error "No go modules detected in ${dir}"
fi

echo "Detected modules:"
for module in "${modules[@]}"; do
  echo "  ${module}"
done


GIT_COMMIT_MESSAGE=${GIT_COMMIT_MESSAGE:-$(create_release_message ${modules})}
GITHUB_REPO=${GITHUB_REPO:-$(extract_repo ${modules})}

target_repo_dir=$(mktemp -d)/$(basename ${GITHUB_REPO})

echo "Cloning target repository ${GITHUB_REPO}"
git clone https://${GITHUB_TOKEN}@github.com/${GITHUB_REPO}.git ${target_repo_dir}

pushd ${target_repo_dir}
git config user.name "${GIT_USER_NAME}"
git config user.email ${GIT_USER_EMAIL}

# checkout or create
git checkout ${GIT_BRANCH} || git checkout -b ${GIT_BRANCH}

echo "Purging modules from repository"
purge_modules $(pwd)

echo "Copying modules to repository"
cp -r ${dir}/* .

git add .
echo "Checking for changes"
if git diff-index --exit-code HEAD --; then
  echo "No changes. Skipping"
  exit 0
fi

git commit -m "${GIT_COMMIT_MESSAGE}"

if $dry_run; then
  echo "Will push to branch: ${GIT_BRANCH}"
else
  git push origin ${GIT_BRANCH}
fi

for module in "${modules[@]}"; do
  create_tag ${module} $(basename ${GITHUB_REPO})
done

popd
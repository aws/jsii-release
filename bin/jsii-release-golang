#!/bin/bash
set -eu

###
#
# Pushes a directory of golang modules to a GitHub repository.
#
# Usage: ./jsii-release-golang [DIR]
#
# DIR is a directory where the golang modules are located (default is `dist/go`). Each subdirectory inside it must be a
#     go module and contain a go.mod file. This directory is pushed as is to the repository root, overriding existing files.
#
# GITHUB_TOKEN       (required): Authentication token that allows to push and tag the repository.
# VERSION            (optional): Module version. Defaults to the value in the 'version' file of the module directory. Fails if it doesn't exist.
# GITHUB_REPO        (optional): GitHub repository to push to. Default is derived from the module name.
# GIT_BRANCH         (optional): Branch to push to. Defaults to 'main'.
# GIT_USER_NAME      (optional): Username to perform the commit with. Defaults to the global git user.name config. Fails it it doesn't exist.
# GIT_USER_EMAIL     (optional): Email to perform the commit with. Defaults to the global git user.email config. Fails it it doesn't exist.
# GIT_COMMIT_MESSAGE (optional): The commit message. Defaults to 'chore(release): $VERSION'.
# DRYRUN             (optional): Set to "true" for a dry run
###

dir=${1:-dist/go}
GIT_BRANCH=${GIT_BRANCH:-main}

if [[ "$dir" != /* ]]; then
  # if given a relative path, remember the full path since we might be changing dirs later on
  dir="$(pwd)/${dir}"
fi

error() { echo "‚ùå $@"; exit 1; }

if ! command -v git &> /dev/null; then
  error "git must be available to run this script"
fi

if [ -z "${GIT_USER_NAME:-}" ]; then
  GIT_USER_NAME=$(git config user.name) || error "Unable to detect username. either configure a global git user.name or pass GIT_USER_NAME env variable"
fi

if [ -z "${GIT_USER_EMAIL:-}" ]; then
  GIT_USER_EMAIL=$(git config user.email) || error "Unable to detect user email. either configure a global git user.email or pass GIT_USER_EMAIL env variable"
fi

dry_run=false
if [[ ${DRYRUN:-"false"} = "true" ]]; then
  echo "==========================================="
  echo "            üèúÔ∏è DRY-RUN MODE üèúÔ∏è"
  echo "==========================================="
  dry_run=true
fi

if [ ! -d ${dir} ]; then
  error "${dir} either doesnt exist or is not a directory"
fi

if [ -z "${GITHUB_TOKEN:-}" ]; then
  error "GITHUB_TOKEN env variable is required"
fi

function create_release_message {
  modules=$1

  message="chore(release):"
  for module in "${modules[@]}"; do
    module_name=$(basename ${module})
    module_version=$(extract_version ${module})
    message="${message} ${module_name}@${module_version}"
  done

  echo ${message}
}

function extract_version {
  modules=$1

  if [ ! -z "${VERSION:-}" ]; then
    module_version=${VERSION}
  elif [ -f ${module}/version ]; then
    module_version=$(cat ${module}/version)
  else
    error "Unable to determine version of module ${module}. Either include a 'version' file, or specify a global version using the VERSION environment variable."
  fi

  echo ${module_version}
}

function extract_repo {
  modules=$1
  # just pick one go.mod file - assumes all modules are pushed to the same repo.
  go_mod=${modules[0]}/go.mod
  full_module_name=$(grep module ${go_mod} | cut -d ' ' -f 2)
  owner=$(echo ${full_module_name} | cut -d '/' -f 2)
  repo=$(echo ${full_module_name} | cut -d '/' -f 3)
  echo ${owner}/${repo}
}

function create_tag {
  module=$1
  repo_name=$2

  module_name=$(basename ${module})
  module_version=$(extract_version ${module})

  tag_name=v${module_version}

  if [ ${module_name} != ${repo_name} ]; then
    # prefix with module name for submodules
    tag_name=${module_name}/${tag_name}
  fi

  git tag -a ${tag_name} -m ${tag_name}
  if $dry_run; then
    echo "Will push tag: ${tag_name}"
  else
    git push origin ${tag_name}
  fi
}

root_module=false
modules=()

# collect the root module if exists
if [ -f ${dir}/go.mod ]; then
  modules+=(${dir})
  root_module=true
fi

# collect submodules if exist
for subdir in $(find ${dir} -mindepth 1 -maxdepth 1 -type d); do
  if [ -f ${subdir}/go.mod ]; then
    modules+=(${subdir})
  fi
done

# at least one go module must exist
if [ ${#modules[@]} -eq 0 ]; then
  error "No go modules detected in ${dir}"
fi

echo "Detected modules:"
for module in "${modules[@]}"; do
  echo "  ${module}"
done


GIT_COMMIT_MESSAGE=${GIT_COMMIT_MESSAGE:-$(create_release_message ${modules})}
GITHUB_REPO=${GITHUB_REPO:-$(extract_repo ${modules})}

target_repo_dir=$(mktemp -d)/$(basename ${GITHUB_REPO})

echo "Cloning target repository ${GITHUB_REPO}"
git clone https://${GITHUB_TOKEN}@github.com/${GITHUB_REPO}.git ${target_repo_dir}

pushd ${target_repo_dir}
git config user.name "${GIT_USER_NAME}"
git config user.email ${GIT_USER_EMAIL}

# checkout or create
git checkout ${GIT_BRANCH} || git checkout -b ${GIT_BRANCH}

for subdir in $(find $(pwd) -mindepth 1 -maxdepth 1 -type d); do
  if [ -f ${subdir}/go.mod ]; then
    # remove to account for deleted files or entire modules
    rm -r ${subdir}
  fi
done

if ${root_module}; then
  # if the root is a module, we sync the entire repo
  rm -r ./*
fi

echo "Copying go modules to repository root"
cp -r ${dir}/* .

git add .
echo "Checking for changes"
if git diff-index --exit-code HEAD --; then
  echo "No changes. Skipping"
  exit 0
fi

git commit -m "${GIT_COMMIT_MESSAGE}"

if $dry_run; then
  echo "Will push to branch: ${GIT_BRANCH}"
else
  git push origin ${GIT_BRANCH}
fi

for module in "${modules[@]}"; do
  create_tag ${module} $(basename ${GITHUB_REPO})
done

popd

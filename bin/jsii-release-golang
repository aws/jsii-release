#!/bin/bash
set -eu

###
#
# Pushes a directory of golang modules to a GitHub repository.
#
# Usage: ./jsii-release-golang [DIR]
#
# DIR: directory where the golang modules are located (default is `dist/go`).
#      Each subdirectory inside it must be a go module and contain a go.mod file.
#
# GITHUB_TOKEN       (required): Authentication token that allows to push and tag the repository.
# VERSION            (required): Module version. Will be used as the repository tag. Required unless NO_TAG is set to a non-zero value.
# GITHUB_REPO        (optional): GitHub repository to push to. Default is derived from the module name.
# GIT_BRANCH         (optional): Branch to push to. Defaults to 'main'.
# GIT_USER_NAME      (optional): Username to perform the commit with. Defaults to the current username (git config user.name)
# GIT_USER_EMAIL     (optional): Email to perform the commit with. Defaults to the current email (git config user.email)
# GIT_COMMIT_MESSAGE (optional): The commit message. Defaults to the last commit of the current repository.
# DRYRUN             (optional): Set to "true" for a dry run
###

dir=${1:-dist/go}
GIT_BRANCH=${GIT_BRANCH:-main}
GIT_USER_NAME=${GIT_USER_NAME:-$(git config user.name)}
GIT_USER_EMAIL=${GIT_USER_EMAIL:-$(git config user.email)}
GIT_COMMIT_MESSAGE=${GIT_COMMIT_MESSAGE:-$(git log -1 --format=%s)}

# remember the full path since we might be changing dirs later on
dir="$(pwd)/${dir}"

error() { echo "‚ùå $@"; exit 1; }

dry_run=false
if [[ -n "${DRYRUN:-}" ]]; then
  echo "==========================================="
  echo "            üèúÔ∏è DRY-RUN MODE üèúÔ∏è"
  echo "==========================================="
  dry_run=true
fi

if [ ! -d ${dir} ]; then
  error "${dir} either doesnt exist or is not a directory"
fi

if [ -z "${GITHUB_TOKEN:-}" ]; then
  error "GITHUB_TOKEN env variable is required"
fi

if [ -z "${VERSION:-}" ]; then
  error "VERSION env variable is required"
fi

go_mod=""

# make sure each directory has a go.mod file
for subdir in $(ls -d ${dir}/*/)
do
  if [ ! -f ${subdir}/go.mod ]; then
    error "expected to find go.mod in ${subdir}. make sure you specify the root directory of all your modules."
  fi
  # pick one mod file to derive repository
  go_mod=${subdir}/go.mod
done

if [ ${go_mod} = "" ]; then
  error "No go modules found in ${dir}"
fi

module_name=$(grep module ${go_mod} | cut -d ' ' -f 2)
domain=$(echo ${module_name} | cut -d '/' -f 1)

if [ ${domain} != "github.com" ]; then
  # the way we clone the repo with the token is a GitHub thing.
  error "'${domain}' domain is not supported. Only GitHub repositories are allowed"
fi

if [ -z "${GITHUB_REPO:-}" ]; then
  owner=$(echo ${module_name} | cut -d '/' -f 2)
  repo=$(echo ${module_name} | cut -d '/' -f 3)
  GITHUB_REPO=${owner}/${repo}
fi

target_repo_dir=$(mktemp -d)/repo

echo "Cloning target repository ${GITHUB_REPO}"
git clone https://${GITHUB_TOKEN}@github.com/${GITHUB_REPO}.git ${target_repo_dir}

pushd ${target_repo_dir}
git config user.name ${GIT_USER_NAME}
git config user.email ${GIT_USER_EMAIL}

# -B to create if it doesn't exist, reset otherwise
git checkout -B ${GIT_BRANCH}

echo "Copying go module to repository root"
cp -r ${dir}/* .

git add .
git commit -m "\"${GIT_COMMIT_MESSAGE}\""

if $dry_run; then
  echo "Will push to branch: ${GIT_BRANCH}"
else
  git push origin ${GIT_BRANCH}
fi

git tag -a $VERSION -m $VERSION

if $dry_run; then
  echo "Will create a tag: ${VERSION}"
else
  git push origin $VERSION
fi

popd